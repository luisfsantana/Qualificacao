% Faz com que o ínicio do capítulo sempre seja uma página ímpar
\cleardoublepage
% Inclui o cabeçalho definido no meta.tex
\pagestyle{fancy}

% Números das páginas em arábicos
\pagenumbering{arabic}

\chapter{Introdução ao escalonamento}\label{cap2}

\section{Escalonamento}\label{cap2:escalonamento}

Escalonamento é um processo de tomada de decisão que é usado como base em muitas indústrias manufatureiras e serviços industriais. Ele lida com a alocação de recursos para tarefas a fim de fornecer períodos de tempo a cada tarefa  e o fim é otimizar um ou mais objetivos.

Encontrar um escalonamento significa encontrar, para cada tarefa, uma alocação de um ou mais intervalos de tempo, em uma ou mais máquinas. O problema de escalonamento correspondente é encontrar um escalonamento que satisfaça um determinado conjunto de restrições.

Em um ambiente genérico de fabricação, o papel do escalonamento das tarefas é 
destacado nas ordens de serviço que são lançadas na configuração da fabricação,
em forma de tarefas com datas de entrega associadas. Essas tarefas 
frequentemente devem ser processadas em máquinas em uma dada ordem ou 
sequência. Os processamentos das tarefas podem atrasar, se certas máquinas 
estiverem ocupadas. Eventos imprevistos no chão-de-fábrica, tais como quebra de 
máquinas ou tempos de processamento maiores que os previstos, também devem 
ser levados em consideração, desde que esses eventos venham a impactar 
diretamente o escalonamento das tarefas. Neste ambiente, o desenvolvimento de um escalonador de tarefas detalhado ajuda a manter a eficiência e o controle das 
operações. 

O chão-de-fábrica não é a única parte da organização que impacta o 
processo de escalonamento. O escalonador também é afetado pelo processo de 
planejamento da produção que lida com o planejamento a médio e a longo prazos 
para toda a organização. Esse processo tenta otimizar toda linha de produtos da 
empresa e a alocação de recursos baseados em seus níveis de estoque, previsões 
de demanda e necessidades de recursos. As decisões tomadas neste nível mais alto 
de planejamento podem impactar o processo de escalonamento diretamente. 

Um exemplo de escalonamento é na indústria de semicondutores  no qual o objetivo é maximizar o tempo de utilização dos equipamentos e minimizar o tempo ocioso e de configuração dos mesmos.

\subsection{Notação dos problemas de escalonamento}
Associados às tarefas, existem as seguintes informações:
\begin{itemize}
\item Tempo de execução ($p_{ij}$) tempo necessário para a execução da tarefa $t_i$ na máquina $m_j$. Denotado apenas por $p_i$ se todas as máquinas forem idênticas
\item Data de disponibilidade ($r_i$) instante em que a tarefa $t_i$ se torna disponível para ser executada
\item Prazo ($d_i$) instante de tempo no qual a tarefa $t_i$ deve estar pronta
\item Peso ($w_i$) normalmente indica um fator de prioridade da tarefa $t_i$
\end{itemize}

A notação utilizada para representar os problemas de escalonamento, é representada pela tripla:   

$\alpha | \beta | \gamma$

$\alpha$ 	que descreve os recursos disponíveis

$\beta$ que descreve as tarefas a serem executadas

$\gamma$ que descreve o critério de otimização

$\alpha$ pode ser representado por:

\begin{itemize}
\item 1 uma única máquina
\item $P$ ou $P_m$ m máquinas paralelas idênticas cada tarefa $t_i$ pode ser processada em qualquer uma das $m$ máquinas por $p_i$ unidades de tempo, se uma tarefa só puder ser executada em um subconjunto das máquinas, a restrição será indicada no campo 
\item $P \infty$ ou $\overline{P}$ é o número ilimitado de máquinas idênticas
\end{itemize}

$\beta$ pode ser representado por:
\begin{itemize}
\item $Q_m$ máquinas paralelas uniformes no qual $m$ máquinas  operam com 
velocidades iguais (a máquina $m_j$ opera com velocidade $v_j$) $p_{ij} = p_i=v_j$
\item $R_m$ máquinas paralelas não-relacionadas, $m$ máquinas diferentes em paralelo
\item $p_{ij} = p_i=v_{ij}$, onde $v_{ij}$ é a velocidade da tarefa $t_i$ na máquina $m_j$
\end{itemize}

Em sistemas de produção as máquinas são consideradas dedicadas, não paralelas. Além disso, uma tarefa $t_i$ é composta por um conjunto de operações denotadas por $O_{i1} | O_{i2} | ... | O_{in}$.

$F_m$ representa o modelo flow-shop, no qual todas as tarefas possuem o mesmo
número de operações, que devem ser executadas na mesma ordem por todas as máquinas, em série.

$O_m$ representa o modelo open-shop, como um flow-shop, mas não há ordem
de precedência entre as operações

$J_m$  representa o modelo  job-shop. Neste modelo cada tarefa possui um roteiro pré-determinado se uma tarefa puder executar em uma mesma máquina mais de uma vez, dizemos que existe recirculação (denotado por $recrc$ ) 

$r_i$ é a data de disponibilidade. Se $r_i$ não estiver no campo, tarefas podem ser iniciadas a qualquer momento. Se $r_i$ estiver no campo, então a tarefa $t_i$ não pode ser iniciada antes do tempo $r_i$ 

$pmtn$ representa interrupção. O processamento de uma tarefa pode ser interrompido e retomado do ponto onde parou, em qualquer máquina.

$s_{ik}$ é o tempo de preparação da máquina (setup). Uma máquina que executou uma tarefa $t_i$ precisa de $s_{ik}$ unidades de tempo para ser preparada antes de executar uma outra tarefa $t_k$

$prec$ relações de precedência. Uma relação de precedência entre duas tarefas indica
que uma tarefa não pode ser iniciada antes do término da execução da outra. Representadas por um grafo de precedências, onde um vértice representa uma tarefa e um arco entre $t_i$ e $t_k$ indica que $t_k$ só pode ser executada após o termino de $t_i$.

$c_{ik}$ tempo de comunicação entre máquinas. A tarefa $t_k$ depende do resultado da execução de $t_i$ . Se $t_k$ não for escalonada na mesma máquina que $t_i$, então deverá esperar mais $c_{ik}$ unidades de tempo antes de poder ser executada.


\subsection{Classes de Escalonamento}

\subsubsection{Escalonamento sem atrasos}

\textbf{Definição:} Um escalonamento válido é dito sem atraso, se nenhuma máquina fica inativa, quando existem tarefas disponíveis para serem executadas.

\subsubsection{Escalonamento ativo}

\textbf{Definição:} Um escalonamento realizável e não-preemptivo é dito ativo se não for possível, apenas trocando a ordem das tarefas/operações em uma máquina, construir um outro escalonamento onde ao menos uma tarefa termine mais cedo e nenhuma outra tarefa seja atrasada.

\subsubsection{Escalonamento semi-ativo}

\textbf{Definição:} Um escalonamento realizado e não-preemptivo é dito semi-ativo se nenhuma tarefa/operação pode terminar mais cedo sem que a ordem do processamento das tarefas de alguma máquina seja mudada.


\subsection{Classificação dos problemas de escalonamento}
Os problemas de programação de operações em máquinas vêm sendo caracterizados por diversos autores em diferentes formas, dentre eles Baker, 1974; Blazewicz et al., 1996; Conway et al., 1967; French, 1982; Graves, 1981 e Pinedo, 2008.

Em situações de escalonar tarefas nas máquinas disponíveis surgem problemas complexos. Pois, as restrições tecnológicas e a medida de desempenho do escalonador devem ser especificadas. As restrições tecnológicas são determinadas principalmente pelo fluxo das tarefas nas máquinas.

Neste contexto, Maccarthy e Liu (1993) classificam os problemas de programação de operações da seguinte forma:
 
\begin{itemize}
\item \textbf{Máquina única} - existe somente uma única máquina disponível para a execução das tarefas;
\item \textbf{Flow shop} - em que todas as tarefas possuem o mesmo fluxo de processamento em todas as máquinas;
 \item \textbf{Job shop} - em que todas as tarefas possuem um roteiro específico de processamento, determinado para cada tarefa;
 \item \textbf{Open shop} - em que não existem roteiros de processamento preestabelecidos para as tarefas;
 \item \textbf{Flow shop permutacional} - flow shop onde a ordem de processamento das tarefas é exatamente a mesma para todas as máquinas;
\end{itemize}

%Cap 3

O problema do sequenciamento em uma única máquina é frequentemente  muito simples e quase sempre parte de um problema de programação complexo.  Segundo Pinedo (2008), os problemas do sequenciamento em uma única máquina  muitas vezes têm propriedades que os de em máquinas em paralelo ou em série  não possuem. Os resultados que podem ser obtidos para os problemas do  sequenciamento em uma única máquina não só fornecem o conhecimento para o ambiente de uma única máquina, como também fornecem base para heurísticas  aplicáveis a ambientes mais complexos. 

Na prática, os problemas de escalonamento em ambientes mais complicados são frequentemente decompostos em subproblemas de uma única máquina. 

Por exemplo, um ambiente complexo, com um único gargalo, pode dar origem a um modelo de sequenciamento em uma única máquina. Dessa forma, o problema do sequenciamento em uma única máquina é importante por diversas razões, dentre elas pode-se citar: 

\begin{itemize}
\item O processo de aprendizado, já que o problema de escalonamento em uma única máquina  pode ilustrar uma variedade de tópicos de escalonamento tornando modelos tratáveis. Esse problema fornece um contexto para que se  investigue muitas medidas de desempenho e técnicas de solução. Além disso, é uma base para o entendimento de  conceitos de escalonamento úteis para modelar sistemas mais complexos. 

\item Para entender completamente o comportamento de um sistema  complexo, é vital entender como funciona cada um de seus componentes e muito frequentemente o problema de uma única máquina aparece como componente elementar em um problema de escalonamento maior. 

\item Algumas vezes é possível resolver o problema de escalonamento em uma única máquina independentemente e então incorporar o resultado em um problema maior. Por exemplo, em um processo com múltiplas operações, frequentemente existe uma operação gargalo e o tratamento dessa operação gargalo, vista como uma análise de um problema de uma única máquina, determina as propriedades de todo o escalonamento. 

\end{itemize}

\subsection{Definição de atributos}

Ao lidar com os atributos para o modelo de uma única máquina, é  útil distinguir entre informações conhecidas previamente e informações que são geradas como resultados de decisões de escalonamento. A informação que é conhecida previamente serve como parâmetro de entrada para função de escalonamento e é usualmente conveniente usar letras minúsculas para denotar esse tipo de informação. As três informações básicas que ajudam a descrever  trabalhos no problema básico determinístico de uma única máquina são: 

\begin{itemize}
\item Tempo de processamento ($t_j$): tempo de processamento requerido pelo trabalho $j$; 
\item Data inicial ($r_j$): o ponto no tempo em que a tarefa $j$ está disponível para processamento; e 
\item Prazo ($d_j$): é o ponto limite no tempo em que o processamento da tarefa $j$ precisa ser concluída. 
\end{itemize} 

Os prazos podem não ser pertinentes em certos problemas, mas estabelecer os prazos (deadlines) é um problema comum na indústria e o problema básico pode auxiliar na determinação do prazo de entrega. É conveniente usar letras maiúsculas para denotar as informações resultantes do escalonamento. 

Tempo de Conclusão ($C_j$). O tempo no qual o processamento do trabalho $j$ é terminado. 

Os critérios quantitativos para escolher uma sequência são geralmente funções dos tempos de conclusão. Duas funções importantes são: 

Tempo de Fluxo (Flowtime) – $F_j$ – Tempo total que o trabalho $j$ fica no sistema: 

$F_j = C_j – r_j$
 
Defasagem (Lateness) – $L_j$ – Diferença entre a data de conclusão e o prazo do trabalho $j$, podendo assumir valores positivos ou negativos

Esses dois valores refletem dois critérios importantes. O tempo de fluxo que mede a resposta do sistema  e representa o tempo que uma tarefa leva entre sua chegada e sua saída. A defasagem, $L_j$, que mede a conformidade do escalonamento em relação ao prazo. É importante notar que a defasagem terá valor negativo quando uma tarefa é finalizada antecipadamente. Defasagens negativas podem representar serviços melhores do que solicitados, enquanto atrasos positivos representam, quase sempre, serviços piores do que requisitados. Em muitas situações, penalidades distintas e outros custos serão associados para defasagens positivas e para defasagens negativas. Dessa forma, tem-se as definições de Atraso (Tardiness) e Antecipação (Earliness): 

Atraso (Tardiness) – $T_j$ – é o quanto o trabalho $j$ atrasou em relação ao seu prazo, caso contrário será considerado zero:
 
$T_j = max\{0, L_j\}$ 

Antecipação (Earliness) – $E_j$ – é o quanto o trabalho $j$ é antecipado em relação ao prazo, caso contrário será considerado zero: 
 
$ E_j = max\{d_j – C_j, 0\} $
 
Makespan – $C_{max}$ – é definido como o maior dentre as datas de 
conclusão ($C_1, . . ., C_n$), ou seja, ao tempo de conclusão do último trabalho a sair do sistema ($C[n]$). Minimizar o makespan usualmente implica em uma boa utilização dos recursos. 

The Total Weighted Completion Time (Tempo total de conclusão ponderado) \\ $1||sum(w_jC_j)$

Primeiro tempo de processamento com menor custo. (WSPT)
Teorema: WSPT é ótima para $1||sum(w_jC_j)$. Neste teorema supomos que temos várias cadeias, e não pode parar de processar uma cadeia que já começou. Nos ajuda decidir qual Cadeia de tarefas precisamos processar primeiro para minimizar o tempo total de processamento.

Supondo agora que o escalonador não precisa terminar todas as tarefas de uma cadeia para começar a processar a outra cadeia. Basicamente este lema nos diz que não faz sentido já que iniciamos a processar uma cadeia interromper para processar outra cadeia. 

\subsubsection{Algorithm 3.1.4 (Total Weighted Completion Time and Chains)}

	Sempre que a máquina é liberado, selecione entre as cadeias restantes aquele com o maior $\rho$-factor. Processar esta cadeia, sem interrupção até e inclusive o trabalho que determina o seu $\rho$-factor.


\subsubsection{The Number of Tardy Jobs}
As tarefas tem datas limites para terminar. A ideia do algoritmo é ordenar as tarefas baseado na data limite de cada tarefa. Deleta-se a tarefa mais longa, caso alguma tarefa tenha a data limite ultrapassada. Se colocarmos pesos, é equivalente ao problema da mochila.

\subsubsection{The Total Tardiness - Dynamic Programming}

Minimizar o número de trabalhos atrasados sum(Tj), NP-Dificil, usa-se a programação dinâmica para resolver (algoritmo pseudo-polinomial). 

\subsubsection{The Total Tardiness - An Approximation Scheme}
Se fez um algoritmo de tempo polinomial que se aproxima da solução ótima. Usa o Esquema de aproximação em tempo polinomial completo.

\subsubsection{The Total Weighted Tardiness (problema fortemente NP-Difícil)}
É o mesmo problema anterior agora com ponderação, problema levanta bastante atenção entre os pesquisadores. O problema da 3-Partição (Dividir um conjunto de inteiros em três partes, no qual a soma de cada parte seja a mesma) se reduz a este problema.

Resumo 

$1||Soma w_jC_j$	Regra WSPT, funciona para chains também
$1||Soma wj(1-e-rC_j)$	Regra WDSP, para cadeias também
$1||L_{max}$	Regra EDD (Primeiro tarefa que termina primeiro)
$1|prec| h_{max}$	Algorithm 3.2.1.
$1|rj|L_{max}$	Branch and bound
$1||S U_j$	Algorithm 3.3.1.
$1||S T_j$	Dynamic programming Alg. 3.4.4.
\\
%Capitulo 4
\subsubsection{The Total Earliness and Tardiness}
Soma total earliness e total tardiness. Depois que uma tarefa se inicia não se pode mais parar o processamento, gera-se o escalonamento ótimo.
\\
\subsubsection{Primary and Secondary Objectives}
Mais realista, pois na pratica temos mais de um objetivo. A ideia é encontrar a melhor solução para um objetivo e a partir dessa solução encontrar uma boa solução na segunda função objetivo. Temos neste caso dois objetivos a serem minimizados. São NP-Hard.
\\
\subsubsection{Multiple Objectives: A Parametric Analysis}
Escalonamento pareto-ótimo – não é possível diminuir o valor de uma função objetivo sem diminuir o valor da outra.
\\
\subsubsection{Job Families with Setup Times}
Tarefas que fazem parte da mesma família podem ser processadas sem a adição de tempo de configuração (podem apresentar tempo de processamento diferentes). Mas se há a troca de uma família $f$ para uma $h$, um tempo $s$ de configuração é necessário. No exemplo com pesos no tempo total de processamento a resolução se deu utilizando programação dinâmica.
\\
\subsubsection{Batch Processing}
Máquina processa um número de tarefas simultaneamente (um batch de tarefas ao mesmo tempo). Comum na industria. 

%cap 5
Modelos de máquina paralela, primeiro determinamos/alocamos os recursos em cada máquina, depois o escalonamento em cada maquina.

A preempção tem um papel mais importante que nos modelos de única máquina, mesmo quando as tarefas são realizadas no mesmo tempo. 

\textbf{Escalonamento Offline} – todos os dados (tempo processamento, prazos, período de submissão da tarefa) são conhecidos em detalhes e podem ser considerados no processo de otimização.

\textbf{Escalonamento On-line} – Os dados não são conhecidos a priori, o tempo de processamento é conhecido apenas depois que a tarefa termina, e a hora que a tarefa foi submetida apenas quando a tarefa é efetivamente submetida. \\


\subsection{Exemplos de modelos de escalonamento}
\subsubsection{The Makespan without Preemptions  \\($P_m || C_{max}$)}
	Utiliza o tempo máximo para completar a tarefa. $P_m$ indica máquinas em paralelo. Problema interessante, pois tem o efeito de balanceamento de carga sobre várias maquinas, importante objetivo na pratica.

	É equivalente ao problema de partição, é NP-Dificil. É  NP-Dificil devido as diferentes combinações de escalonamento mas maquinas. Problema resolvido através de heurística. A huerística chama-se Primeiro Tempo de Processamento Mais Longo (LPT).

	CP rule – O nível mais alto primeiro para tempo de processamento igual a 1 e com precedência, é ótimo. LNS é equivalente a CP Rule, não é necessariamente ótima com restrições de precedência arbitrária.

	LFJ - Least Flexible Job  first . Para o caso de restrições de subconjunto de maquinas a serem processadas, seleciona as maquinas disponíveis no menor numero de maquinas. \\
	
\subsubsection{The Makespan with Preemptions}

	Mesmo exemplo, mas agora com preempção permitida $P_m|prmp|C_{max}$. Tratado como um problema de programação linear. \\		

\subsubsection{The Total Completion Time without Preemptions}
$P_m| | Sum(C_j)$ – SPT – A tarefa mais curta primeiro tem escalonamento ótimo.
$P_m| prec | Sum(C_j)$ – agora temos precedência na ordem das tarefas, é NP-Dificil, restrições de precedência arbitrária\\

\subsubsection{The Total Completion Time with Preemptions} 
$Q_m |  prepr | Sum(C_j)$ – Qm indica maquinas com diferentes velocidades de processamento. Shortest Remaining Processing Time  on the Fastest Machine  = tarefa mais curta para a maquina mais rapida e assim por diante.

Online Scheduling Escalonamento online, ou seja, ao mesmo tempo que estamos escalonando.

%Cap 6. 

Máquinas em série, ideia da manufatura, que existe uma sequencia de máquinas que a matéria-prima precisa passar para se tornar um produto final. Flexible Shop são máquinas em série com vários estágios, cada estágio tem várias máquinas em paralelo. Objetivo para esse ambiente é o Makespan (tempo total $C_{max}$). 

O escalonamento flow shop é um sistema de trabalho de tarefas em máquinas em série, onde cada tarefa tem que ser processada em cada uma das máquinas. Todas as tarefas devem seguir a mesma rota, ou seja, elas têm que ser processadas, primeiro na máquina 1, depois na máquina 2, e assim por diante. Após a conclusão de uma tarefa em uma máquina, a tarefa se junta à fila da próxima máquina. O problema de escalonamento flow shop é classificado como NP-difícil para a maioria dos problemas clássicos

%cap 7
O Job-shop Scheduling Problem (JSP) pode ser descrito por: $n$ tarefas, onde cada tarefa é composta por $j$ operações que devem ser processadas em $m$ máquinas. Cada operação $j$ utiliza uma das $m$ máquinas com um tempo de processamento fixo. Cada máquina processa uma operação por vez sendo que não ocorre interrupção. As operações devem ser processadas em ordem através de um roteiro pré-estabelecido. O problema consiste em encontrar um escalonamento que obedeça as precedências de operações nas máquinas tal que minimize o makespan $C_{max}$ dado o processamento da ultima tarefa. 

Job Shop é um Flow Shop, no qual as tarefas tem rotas diferenciadas, mas pré-determinadas.

%cap 8
No Open-Shop, a rota das tarefas são abertas, não é pré-determinada. Open Shop: O ambiente de máquinas típico de open shop caracteriza-se pelo fato de não existir uma sequência pré-definida a ser seguida por cada tarefa $j$. Posto de outra forma, é fornecido ao escalonador liberdade de escolha da sequência a ser seguida por cada tarefa $j$ ao longo do sistema.


\section{Balancemento de Carga}\label{intro:carga}

O balanceamento de carga é uma técnica aplicada para distribuir a carga de trabalho entre dois ou mais servidores, enlaces de rede, CPU, ou outros recursos; a fim de otimizar a utilização destes recursos, maximizar o desempenho e evitar sobrecarga. Em geral o balanceamento de carga consiste em três fase~\cite{carga}. A primeira, consiste na coleta de informações. A segunda, busca determinar qual seria a distribuição ótima para o estado em que o sistema se encontra. E por fim a terceira fase, que a ação de balanceamento é executada. O balanceador de carga pode ter uma das seguintes classificações:

\begin{itemize}
\item Estático A regra de balanceamento é definida uma única vez, baseada em informações estáticas do sistema ou aplicações.

\item Dinâmico A regra de balanceamento é modificada em resposta ao estado atual do sistema ou das aplicações. O estado do sistema será constantemente atualizado e as decisões tomadas são baseadas nas informações atuais e possivelmente, dos estados anteriores do sistema.
\end{itemize}

Ao balancear a carga, tenta-se evitar que no sistema, existam simultaneamente máquinas com recursos subutilizados e máquinas com recursos super utilizados. Na maioria dos casos, realizar balanceamento de carga ótimo é impraticável, devido a complexidade computacional para resolver o problema. Conforme~\cite{virtual}, o problema de balanceamento de carga  é similar a problemas de alta complexidade computacional, que não podem ser resolvido de maneira exata em tempo polinomial. Para contornar esta limitação, heurísticas ou algoritmos de aproximação, são usados para apresentarem soluções aproximadas do balanceamento de carga ótimo.

\section{GPUs}\label{intro:historico}

As GPUs vêm se mostrando uma excelente alternativa na área de computação de alto-desempenho para aplicações que exigem um alto grau de paralelismo~\cite{gpu}. GPUs modernas possuem dezenas de núcleos, cada um deles bastante simples, mas que utilizados em paralelo geram um alto poder computacional~\cite{cuda}.

Muitas aplicações já utilizam o poder de processamento das GPUs, exemplos são mecânica dos fluidos \cite{fluido}, visualização científica \cite{visualizacao},  aprendizado de máquina \cite{Aprendizado}, entre outras. Devido ao relativo baixo custo de placas gráficas contendo GPUs, sua utilização é uma ótima alternativa para pesquisadores pertencentes a instituições com poucos recursos financeiros e com grande necessidade de recursos computacionais.


\section{Suporte ao Paralelismo de Tarefas}
Diversas ferramentas de programação suportam paralelismo de tarefas em CPUs multicore. Recentemente, alguns trabalhos em andamento têm buscado oferecer suporte a esse paradigma também em sistemas híbridos compostos por CPUs e GPUs.


\subsection{StarPU}
 
O StarPU~\cite{starpu} é uma ferramenta para programação paralela que oferece suporte para arquiteturas híbridas, como CPUs multicore e aceleradores. O StarPU propõe uma abordagem de tarefas independente da arquitetura base. São definidos codelets como uma abstração de uma tarefa que pode ser executada em um núcleo de uma CPU multicore ou submetido a um acelerador. Cada codelet pode ter múltiplas implementações, uma para cada arquitetura em que o codelet pode ser executado, utilizando as linguagens ou bibliotecas específicas para a arquitetura alvo. Uma aplicação StarPU é descrita como um conjunto de codelets com suas dependências de dados.

A ferramenta possui um conjunto de políticas de escalonamento implementadas que o programador pode escolher de acordo com as características da aplicação. A principal delas faz uso do algoritmo de escalonamento estático HEFT (Heterogeneous Earliest Finish Time) para escalonar as tarefas com base em modelos de custo de execução das tarefas.



\subsection{Charm++}

No Charm++~\cite{kunzman2006charm++} as tarefas são representadas pelos chares, que são objetos paralelos e representam unidades locais de trabalho. Cada chare possui dados locais, métodos para tratamento de mensagens e possibilidade de criar novos chares, assim como processos MPI-2. Existe ainda um tipo especial de chare, chamado branch-office, que possui uma ramificação em cada processador e um único nome global. Branch-office chares oferecem métodos sequenciais que podem ser acessados por chares de forma transparente em qualquer processador.

No Charm++ a sincronização pode ser feita através de Futures, objetos de comunicação, replicados ou compartilhados. O future  é uma estrutura que serve para armazenar um valor que pode ser acessado no futuro por outro chare. O acesso a essa estrutura  é bloqueante e pode ser comparado a um acesso ao resultado de um método spawned precedido de uma chamada sync. A utilização de objetos de comunicação permite que um chare se comunique por troca de mensagens, tornando a comunicação semelhante à realizada com MPI. Os demais objetos introduzem conceitos para comunicação não encontrados nos outros ambientes.

O Charm foi uma das primeiras implementações do conceito de Atores, que são objetos concorrentes que se comunicam apenas por troca de mensagens. Charm++ é baseado no Charm e suporta diferentes modos de compartilhamento de informações. Ele reúne recursos propostos em outros ambientes, como objetos sequenciais e paralelos, comunicação por troca de mensagens e futures. O Cilk é um ambiente de programacção paralelo focado em arquiteturas SMP. Ele  é baseado na linguagem C. O Cilk oferece também um escalonador de processos que é provado ser eficiente. Baseando-se no Cilk, foi desenvolvido um ambiente para execução de programas em arquiteturas com memória distribuída e aproveitamento de recursos ociosos, chamado Cilk-NOW~\cite{Blumofe:1997:ARP:1268680.1268690}.

\subsection{Kaapi}

O XKaapi~\cite{gautier:hal-00799904} é uma reimplementação do KAAPI com suporte a paralelismo de tarefas "de grão fino". O KAAPI (Kernel for Adaptative, Asynchronous Parallel and Interactive programming) é uma ferramenta para computação paralela em CPUs multicore e clusters. A implementação atual do XKaapi oferece suporte a arquiteturas multicore e extensões para suporte eficiente a GPUs foram propostas em (HERMANN et al., 2010; LIMA et al., 2012). O XKaapi é composto por um conjunto de APIs (Application Programming Interfaces) e pelo kernel, um ambiente de execução para as APIs que oferece escalonamento baseado em roubo de tarefas. A Kaapi++ é a interface do XKaapi baseada em um DFG (Data Flow Graph) para C++ e é dividida em três componentes: a assinatura da tarefa (task signature) onde são definidos o número e as características dos parâmetros da tarefa; a implementação da tarefa (task implementation) que especifica a implementação da tarefa para uma arquitetura e a criação da tarefa (task creation) que submete a tarefa para a pilha de execução.

\subsection{Cilk}

A ferramenta para programação paralela Cilk~\cite{Blumofe:1995:CEM:209936.209958, Blumofe:1997:ARP:1268680.1268690} é uma extensão da linguagem C para permitir a submissão, execução e sincronização de tarefas paralelas. A implementação de Cilk é baseada no algoritmo de escalonamento dinâmico por meio de roubo de tarefas. Cilk define tarefas como funções individuais que podem submeter novas tarefas dinamicamente. A sincronização é feita permitindo que as tarefas esperem pelas tarefas filhas, ou seja, tarefas que foram submetidas pela tarefa original.


\subsection{Intel TBB}

O Intel TBB (Threading Building Blocks)~\cite{Kim:2011:MDP:1920042.1920078} é uma biblioteca baseada em templates para programação paralela em C++ que faz uso de threads. Essa biblioteca permite expressar o paralelismo em diversos paradigmas de programação paralela como o paralelismo de dados, de laços ou de tarefas. As unidades de trabalho paralelas resultantes são escalonadas em threads por meio de um algoritmo de roubo de tarefas inspirado no ambiente Cilk.

\subsection{OpenMP}

OpenMP (Open Multi-Processing)~\cite{Quinn:2003:PPC:1211440} é uma ferramenta para programação paralela baseada na adição de diretivas de compilação em códigos C, C++ e Fortran. As diretivas OpenMP são utilizadas para indicar a paralelização de laços ou trechos de código. A partir da versão 3.0 (OpenMP ARB, 2008) foi inserido o conceito de tarefas, o que permite a utilização do paralelismo de tarefas através do uso de diretivas para delimitação de trechos de código como unidades de trabalho paralelas. A especificação OpenMP não define uma política para o escalonamento das tarefas, ficando essa escolha a cargo de cada implementação.
